Bezier Curve
============
In order to solve the problem of generating a dynamic placement path for the dominoes the Bezier format of representing curves was ideal. 

.. figure::  imgs/adaptive_path.gif
   :align:   center

The ability to generate different curves based upon two positions and orientaions was well suited to our project. Additionally the abilty to adjust how much influence the start and end orientations have on the curve proved very helpful when automating the adaption of the curve if an inverse kinematics solution couldn't be found. 

The implementation for this part of the project is split into two python files, ``bezier_conversion.py`` and ``bezier_interpolation.py``. Where bezier conversion contains the code that defines the Bezier class we created and bezier interpolation uses this class, and the placed brick positions to generate the positions and orientations of the bricks go inbetween.

T - Space vs Cartesian Space
----------------------------
Beziers work by converting a value from 0 and 1 into x and y coordinates. They're defined by 4 control points.

[insert image of control points]

These control points are used in the following equation:

.. math:: B(t)=\sum_{i=0}^{n} {}_n \mathrm{ C }_i (1-t)^{n-i} t^{i} P_{i}

As the value of t increases, the x and y coordinates move from the start to the end of the path.

.. figure::  imgs/bt.gif
   :align:   center

Representing a Bezier in Code
-----------------------------
All of the code in this section is from the ``bezier_conversion.py`` file. The line numbers of the following code snippets correspond to their position within this file. 

The Bezier Class
^^^^^^^^^^^^^^^^
We chose to create a new Bezier object type, to make it more intuitive to work with the Beziers within the code.

The instantiation of a Bezier object takes a string input which can be copied from xml generated by graphics packages such as Adobe Illustrator or Inkscape. 

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :pyobject: Bezier.__init__
   :linenos:
   :lineno-start: 11

NOTE: Alternatively you can easily construct your own string, as it is essentially just a list of coordinates in the following format:


Conversion
^^^^^^^^^^^
The conversion method is called during the instantiation of a Bezier object. It iterates through the characters in the inputted string and extracts the coordinates from it.

These coordinates are converted into ``Node`` objects. The node class is very simple, it has two attribute: x and y. It has no methods other than ``__init__``.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :pyobject: Node
   :linenos:
   :lineno-start: 3


Each ``Node`` object is then appended to a list stored in the ``Bezier`` attribute ``p``. The reason this attribute is called p and not something more explanatory such as point list, is to allow the later functions to read more like the bezier equation outlined above. For example referencing point :math:`P_2` can be done using ``Bezier.p[2]`` which reads very similarly making the code more legible.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :pyobject: Bezier.conversion
   :linenos:
   :lineno-start: 16
   
B_x
^^^
This method takes a t value and returns the corresponding x coordinate. The variables ``c0`` - ``c1`` are the different sections of the expanded form of the Bezier equation shown above.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :pyobject: Bezier.B_x
   :linenos:
   :lineno-start: 59

The code is the equvilent of the following mathematical expression:

.. math:: B_x(t)=(1-t)^{3} P_{0x} + 3(1-t)^{2} t P_{1x} + 3(1-t) t^{2} P_{2x} + t^{3} P_{3x}

B_y
^^^
This method takes a t value and returns the corresponding y coordinate. The variables ``c0`` - ``c1`` are the different sections of the expanded form of the Bezier equation shown above.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :pyobject: Bezier.B_y
   :linenos:
   :lineno-start: 66

The code is the equvilent of the following mathematical expression:

.. math:: B_y(t)=(1-t)^{3} P_{0y} + 3(1-t)^{2} t P_{1y} + 3(1-t) t^{2} P_{2y} + t^{3} P_{3y}

Creating a Bezier from the Start and End Bricks
-----------------------------------------------
The code descibed below is all from the ``bezier_interpolation.py`` script unless otherwise stated. This function defined in this script takes the placed brick's positions and orientations and returns a list of poses for all the bricks that need to be placed inbetween them.

In order to use the Bezier class, ``bezier_conversion.py`` is imported at the beginning of the code.

.. literalinclude:: dominoes_code/bezier_interpolation.py
   :language: python
   :lines: 2
   :linenos:
   :lineno-start: 2

.. figure::  imgs/bricks_to_curvy_boi.png
   :align:   center

The coordinates and brick rotation are fed into the ``create_path`` function from the main ``right_placement.py`` script.

This information is used to generate a curve.

The positioning of the control points
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The points :math:`P_0` and :math:`P_3` are simply the start and end coordinates fed into the function. However working our where :math:`P_1` and :math:`P_2` should be takes a little bit more work. 

The angle of rotation, plus the variable handle influence variable are used to calculate the change in x and change in y from the start and end position with some simple trigonometry.

.. literalinclude:: dominoes_code/bezier_interpolation.py
   :language: python
   :lines: 13-37
   :linenos:
   :lineno-start: 13

These coordinates are then fed into a string variable called ``bezier_string`` which is consitent with the XML standard for representing Bezier curves. The variable ``bezier_string`` is passed as an argument in the instantiation of a new Bezier object. This means that we can now calculate the x and y coordinates of every point along the generated path by calling ``brick_path.B_x(t)`` and ``brick_path.B_y(t)``.

.. literalinclude:: dominoes_code/bezier_interpolation.py
   :language: python
   :lines: 39 - 41
   :linenos:
   :lineno-start: 39

Evenly Spacing the Bricks
-------------------------
Evenly Spaced t Values
^^^^^^^^^^^^^^^^^^^^^^

It would seem intuitive that if you wanted to evenly place 9 bricks along the path then you would increment the t value in 8 even steps.

.. code-block:: python
   
   for i in range(9):
      t = i * (1/8)
      x = brick_path.B_x(t)
      y = brick_path.B_y(t)

However due to the relationship t has to the curvature of the path, you actually get something that looks more like this.

.. figure::  imgs/uneven.png
   :align:   center

And whilst it is good enough for creating a nice pattern, in the case of dominoes, you need to be able to specify how far apart they are spaced so you know that they will knock each other over.

Approximating the Length of a Bezier
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The easiest way to evenly space the points along the bezier would be to divide the bezier's length by the design number of bricks. However there is no mathematically simple way to calculate this accurately. Therefore an approximation of the length of the bezier has been used instead.

.. figure::  imgs/length.gif
   :align:   center

The approximation code was added as a method to the Bezier class in the ``bezier_conversion.py`` file.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :pyobject: Bezier.length_approximation
   :linenos:
   :lineno-start: 73
   
The way this approximation works is to assume that the curve is actually a series of straight lines. The length of these lines are calculated and added together.

The resolution, :math:`R` is used to calculate an even spacing in the t-space. So the points are spaced :math:`\frac{1}{R}` apart.

.. figure::  imgs/length_approximation.png
   :align:   center

For each point along the path that has been calculated, the distance to the previous point is calculated using simple using simple trigonometry on line 87. This length is added to a running total, so the total length of the curve can be estimated.

The higher the resolution, the more accurate the estimation. However increasing the resolution also increases the running time of the algorithm. For our interpolation code we use a resolution of 150 as it provided a converged value for the length to 3 decimal places. We found this to be a good balance between speed and accuracy.

Utilizing Memoisation to Improve Efficiency
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
To place bricks evenly along the path, it was covenient to not only know the total length of the curve. But to be able to specify a distance along the curve and get the x and y coordinates at that position. 

This could be done by performing the iteration each time a coordinate a certain distance along the path needed to be calculated. However this would've been highly inefficient.

Therefore we utilized memoisation, to create a cache of which distances correspond to which t value. (This t value can then be fed into the ``brick_path.B_x(t)`` and ``brick_path.B_y(t)`` methods to get the coordinate values.)


.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :lines: 76-90
   :emphasize-lines: 76, 88-99
   :linenos:
   :lineno-start: 79

In the ``length_approximation method`` each time a new length is calculated a dictionary called ``t_map`` is updated. Not only is this dictionary updated with the distance which corresponds with current t value being explored, but all the values of distance that exist between the previously calculated length and the current length to 3 decimal places are stored as keys to that ``t`` value.

This has the effect of any distance you look up effectively snapping to the closest t_value which distance has been calulated.


Converting Distance Along Path to Cartesean Coordinates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
First of all the brick path's length is calculated using the method descibed above.

.. literalinclude:: dominoes_code/bezier_interpolation.py
   :language: python
   :lines: 42
   :lineno-start: 42

Then an ideal spacing is defined, in our case this is 14 as this corresponds to the length of a toppled domino. This spacing is used to determine how many bricks will fit along that path. Then, as it is unlikely that the ideal spacing will divide exactly into the total length, the actual spacing is calculated by dividing the path length by the number of bricks being used.

.. literalinclude:: dominoes_code/bezier_interpolation.py
   :language: python
   :lines: 46 - 49
   :lineno-start: 46

The calculated spacing is then used to find the x and y coordinates for each brick. The desired distance along the path is looked up in the t_map, and the outputted t value is used to calulate the x and y values.

.. literalinclude:: dominoes_code/bezier_interpolation.py
   :language: python
   :lines: 53 - 66
   :lineno-start: 53

On lines 53 and 56 a scaling and tranlation transfomation is applied, this is becuase the Bezier and the Baxter robot have different base coordinate systems and units.

This method successfully evenly spaces the bricks. However as can be seen, this is still not a functional domino path, as all the bricks are facing the same direction.

.. figure::  imgs/even_but_flat.png
   :align:   center

Rotating the Bricks to be Normal to the Path
---------------------------------------------
Calculating Tangent Line
^^^^^^^^^^^^^^^^^^^^^^^^
To overcome this issue the tangent to the curve at each coordinate is calculated, and the bricks are then placed so they're normal to the curve.

The tangent is calculated by deviating very slighlty from the specified t value using the variable ``dt``. 



Converting to Rotation
^^^^^^^^^^^^^^^^^^^^^^

