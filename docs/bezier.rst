.. toctree::
   :maxdepth: 2

Bezier Curve
============
In developing the placing sequence, the group implemented an SVG code to dynamically place each brick after the pick sequence. The SVG uses a bezier curve with two handles; the curvature of the SVG is determined by the length of the handles.

T - Space vs Cartesian Space
----------------------------
Beziers work by converting a value from 0 and 1 into x and y coordinates. They're defined by 4 control points.
[insert image of control points]

These control points are used in the following equation:

.. math:: B(t)=\sum_{i=0}^{n} {}_n \mathrm{ C }_i (1-t)^{n-i} t^{i} P_{i}

Representing a Bezier in Code
-----------------------------
All of the code in this section is from the ``bezier_conversion.py`` file.

The Bezier Class
^^^^^^^^^^^^^^^^
We chose to create a new Bezier object type, to make it more intuitive to work with the Beziers within the code.

The instantiation of a Bezier object takes a string input which can be copied from xml generated by graphics packages such as Adobe Illustrator or Inkscape. 

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :lineos:

NOTE: Alternatively you can easily construct your own string, as it is essentially just a list of coordinates in the following format:


Conversion
^^^^^^^^^^^
The conversion method is called during the instantiation of a Bezier object. It iterates through the characters in the inputted string and extracts the coordinates from it.

These coordinates are converted into Node objects. The node class is very simple, it has two attribute: x and y. It has no method.

Each ``Node`` object is then appended to a list stored in the ``Bezier`` attribute ``p``. The reason this attribute is called p and not something more explanatory such as point list, is to allow the later functions to read more like the bezier equation outlined above. For example referencing point ``P_2`` can be done using ``Bezier.p[2]`` which reads very similarly making the code more legible.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :lines: 16-57
   
B_x
^^^
This method takes a t value and returns the corresponding x coordinate. The variables ``c0`` - ``c1`` are the different sections of the expanded form of the Bezier equation shown above.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :lines: 59-64

The code is the equvilent of the following mathematical expression:

.. math:: B_x(t)=(1-t)^{3} P_{0x} + 3(1-t)^{2} t P_{1x} + 3(1-t) t^{2} P_{2x} + t^{3} P_{3x}

B_y
^^^
This method takes a t value and returns the corresponding y coordinate. The variables ``c0`` - ``c1`` are the different sections of the expanded form of the Bezier equation shown above.

.. literalinclude:: dominoes_code/bezier_conversion.py
   :language: python
   :lines: 66-71
   :lineos:

The code is the equvilent of the following mathematical expression:

.. math:: B_y(t)=(1-t)^{3} P_{0y} + 3(1-t)^{2} t P_{1y} + 3(1-t) t^{2} P_{2y} + t^{3} P_{3y}

Creating a Bezier from the Start and End Bricks
-----------------------------------------------

Evenly Spacing the Bricks
-------------------------

Approximating the Length of a Bezier
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Utilizing Memoisation to Improve Efficiency
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Converting Distance Along Path to Catesean Coordinates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Rotating the Bricks to be Normal to the Path
---------------------------------------------
Calculating Tangent Line
^^^^^^^^^^^^^^^^^^^^^^^^

Converting to Rotation
^^^^^^^^^^^^^^^^^^^^^^

